<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456929083237">{:repl-history {:ide [], :local [&quot;({:keys [kutya macska]} {:kutya \&quot;1\&quot; :macska \&quot;2\&quot;})&quot; &quot;(let [{:krumpli [kutya macska]} {:kutya \&quot;1\&quot; :macska \&quot;2\&quot;}]\n  (println kutya))&quot; &quot;(let [{:keys [kutya macska]} {:kutya \&quot;1\&quot; :macska \&quot;2\&quot;}]\n  (println kutya))&quot; &quot;(def indexes {1 2 3 4})&quot; &quot;(let [{x y &amp; more} indexes]\n  (str x y more))&quot; &quot;(let [{x y &amp; more} indexes]\n  (println x y more))&quot; &quot;(let [{:keys [x y z k]} indexes]\n  (println x y))&quot; &quot;(def indexes {:1 10 :2 20})&quot; &quot;(let [{:keys [1]} indexes]\n  (println 1 ))&quot; &quot;(let [{:keys [1 2]} indexes]\n  (println 1 ))&quot; &quot;(def indexes {:first 10 :second 20})&quot; &quot;(let [{:keys [first second]} indexes]\n  (println first))&quot; &quot;(let [{macska kutya} indexes]\n  (println macska))&quot; &quot;(let [{:keys[macska kutya]} indexes]\n  (println macska))&quot; &quot;(let [{:keys [status erro body headers] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type \&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (println resp))&quot; &quot;(let [{:keys [status erro body headers] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (println resp))&quot; &quot;(let [{:keys [status erro body headers authToken] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (println authToken))&quot; &quot;(let [{:keys [status erro body headers [body authToken]] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (println authToken))&quot; &quot;(let [{:keys [status erro body headers [body authToken]] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (println status))&quot; &quot;(let {:keys [kutya macska]} {:kutya \&quot;1\&quot; :macska \&quot;2\&quot;}&quot; &quot;(doc get-in)&quot; &quot;(let [{:keys [status erro body headers ] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (body))&quot; &quot;(let [{:keys [status erro body headers ] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  body)&quot; &quot;(let [{:keys [status erro body headers ] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (json/read-json body))&quot; &quot;(let [{:keys [status erro body headers ] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (:authToken (json/read-json body)))&quot; &quot;(def login\n  (let [{:keys [body] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (:authToken (json/read-json body))))&quot; &quot;(defn login []\n  ((let [{:keys [body] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (:authToken (json/read-json body)))))&quot; &quot;login&quot; &quot;(defn login []\n  (let [{:keys [body] :as resp}\n      @(http/request\n         {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :method :post\n          :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})})]\n  (:authToken (json/read-json body))))&quot; &quot;(defn login []\n  (let [{:keys [body] :as resp}\n      @(http/request\n         (merge common {:url \&quot;http://nak-test.dbx.hu/api/auth/v1/users/authenticate\&quot;\n          :body (json/write-str {:userName \&quot;korteheni\&quot; :password \&quot;Krumpli10\&quot;})}))]\n  (:authToken (json/read-json body))))&quot; &quot;(login)&quot; &quot;(do (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(doall (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(take 10 (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; ,)&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; \&quot;,\&quot;)&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; :separator ,)&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; {:separator })&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; {:separator ,})&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot; {:separator \&quot;,\&quot;})&quot; &quot;(println (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;[\&quot;resources/csv/cig_parnter.csv\&quot;]&quot; &quot;(take (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(take 1 (csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv234\&quot;)&quot; &quot;(csv/read-csv \&quot;resources/csv/cig_partner.csv\&quot;)&quot; &quot;(csv/read-csv (io/reader \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(defn csv-in\n  [path]\n  (csv/read-csv (io/reader path)))&quot; &quot;(reduce + [1 2 3] [1 2 3])&quot; &quot;(map hash-map [:key1 :key2] [\&quot;val1\&quot; \&quot;val2\&quot;])&quot; &quot;((defn csv-to-map)\n  [vectors]\n  (let [[keys vals] vectors])\n  (map hash-map keys vals))&quot; &quot;(defn csv-to-map\n  [vectors]\n  (let [[keys vals] vectors]\n    (map hash-map keys vals)))&quot; &quot;(doc merge)&quot; &quot;(merge (csv-to-map (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)))&quot; &quot;(csv-to-map (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [[i1] [i2]] (hash-map i1 i2)) (csv-to-map \&quot;resources/cig_parnter.csv\&quot;))&quot; &quot;(reduce (fn [[i1] [i2]] (hash-map i1 i2)) (csv-in \&quot;resources/cig_parnter.csv\&quot;))&quot; &quot;(reduce (fn [[i1] [i2]] (hash-map i1 i2)) (csv-in \&quot;resources/csv/cig_parnter.csv\&quot;))&quot; &quot;(defn create-partner\n  [authToken partner-path]\n  (http/request\n    (merge common\n           {:url \&quot;http://nak-test.dbx.hu/api/partner/partners\&quot;\n            :body (csv-in partner-path)\n            :header {\&quot;X-Auth_Token\&quot; authToken}})))&quot; &quot;(reduce (fn [ret [[i1] [i2]]]\n          (merge (hash-map i1 i2) ret)\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)))&quot; &quot;(reduce (fn [ret [i1] [i2]]\n          (merge (hash-map i1 i2) ret)\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)))&quot; &quot;(reduce (fn [ret [i1] [i2]]\n          (merge (hash-map i1 i2) ret)\n          {} (vector(csv-in \&quot;resources/csv/cig_partner.csv\&quot;))))&quot; &quot;(reduce (fn [ret [i1] [i2]]\n          (merge (hash-map i1 i2) ret))\n          {} (vector(csv-in \&quot;resources/csv/cig_partner.csv\&quot;)))&quot; &quot;(reduce (fn [ret [i1 i2]]\n          (hash-map i1 i2) ret)\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [ret [i1 i2]]\n          (hash-map i1 i2))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [ret [i1 i2]]\n          (megre (hash-map i1 i2) ret))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [ret [i1] [i2]]\n          (merge (hash-map i1 i2) ret))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [ret [[i1] [i2]]]\n          (merge (hash-map i1 i2) ret))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(reduce (fn [ret [i1 i2]]\n          (merge (hash-map i1 i2) ret))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(csv-in \&quot;resources/csv/cig_partner.csv\&quot;)&quot; &quot;[\&quot;asd\&quot; \&quot;fgh\&quot;]&quot; &quot;(vector (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(take 1 (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(seq (take 1 (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)))&quot; &quot;(reduce (fn [ret ([i1] [i2])]\n          (merge (hash-map i1 i2) ret))\n          {} (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))&quot; &quot;(let [v1 (first (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))])&quot; &quot;(let [v1 (first (csv-in \&quot;resources/csv/cig_partner.csv\&quot;))]\n  (println v1))&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (println v1))&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (println v1)\n  (println v2))&quot; &quot;(doc map)&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            (merge (hash-map i1 i2) ret))\n          {} v1))&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            (merge (hash-map i1 i2) ret))\n           v1 v2))&quot; &quot;(+ 1 2)&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            merge (hash-map i1 i2) ret)\n          {} v1 v2))&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            merge (hash-map i1 i2) ret)\n          v1 v2))&quot; &quot;(let [[v1 v2] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            (merge (hash-map i1 i2) ret))\n          {} v1 v2))&quot; &quot;(reduce (fn [ret [i1] [i2]]\n          (merge (hash-map i1 i2) ret))\n        {} v1 v2)&quot; &quot;(doc reduce)&quot; &quot;(let [[v1] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1] [i2]]\n            (merge (hash-map i1 i2) ret))\n          {} v1))&quot; &quot;(let [[v1] (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [[i1] [i2]]]\n            (merge (hash-map i1 i2) ret))\n          {} v1))&quot; &quot;(let [v1 (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [[i1] [i2]]]\n            (merge (hash-map i1 i2) ret))\n          {} v1))&quot; &quot;(let [v1 (csv-in \&quot;resources/csv/cig_partner.csv\&quot;)]\n  (reduce (fn [ret [i1 i2]]\n            (merge (hash-map i1 i2) ret))\n          {} v1))&quot; &quot;(ns nak-test00.core\n  (:require [org.httpkit.client :as http]\n            [clojure.data.csv :as csv]\n            [clojure.data.json :as json]\n            [clojure.core]\n            [clojure.java.io :as io])\n  (:gen-class))&quot; &quot;(def common {:method :post\n             :headers {\&quot;Content-Type\&quot; \&quot;application/json\&quot;}})&quot; &quot;(def cig-path \&quot;resources/csv/cig_partner.csv\&quot;)&quot; &quot;(def ober-path \&quot;resources/csv/ober_partner.csv\&quot;)&quot; &quot;(csv-in ober-path)&quot; &quot;(let [tag val] csv-in cig-path)&quot; &quot;(let [[tag val] csv-in cig-path]\n  tag\n  val)&quot; &quot;(let [[tag val] (csv-in cig-path)]\n  tag\n  val)&quot; &quot;(let [[tag val] (csv-in cig-path)]\n  (println tag)\n  (println val))&quot;], :remote []}}</component>
</project>